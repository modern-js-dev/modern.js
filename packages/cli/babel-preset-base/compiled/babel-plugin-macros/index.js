(()=>{"use strict";var e={146:(e,r,o)=>{const t=o(17);const n=o(606);const a=/[./]macro(\.c?js)?$/;const testMacrosRegex=e=>a.test(e);class MacroError extends Error{constructor(e){super(e);this.name="MacroError";if(typeof Error.captureStackTrace==="function"){Error.captureStackTrace(this,this.constructor)}else if(!this.stack){this.stack=new Error(e).stack}}}let i=null;function getConfigExplorer(){return i=i||o(603).cosmiconfigSync("babel-plugin-macros",{searchPlaces:["package.json",".babel-plugin-macrosrc",".babel-plugin-macrosrc.json",".babel-plugin-macrosrc.yaml",".babel-plugin-macrosrc.yml",".babel-plugin-macrosrc.js","babel-plugin-macros.config.js"],packageProp:"babelMacros"})}function createMacro(e,r={}){if(r.configName==="options"){throw new Error(`You cannot use the configName "options". It is reserved for babel-plugin-macros.`)}macroWrapper.isBabelMacro=true;macroWrapper.options=r;return macroWrapper;function macroWrapper(r){const{source:o,isBabelMacrosCall:t}=r;if(!t){throw new MacroError(`The macro you imported from "${o}" is being executed outside the context of compilation with babel-plugin-macros. `+`This indicates that you don't have the babel plugin "babel-plugin-macros" configured correctly. `+`Please see the documentation for how to configure babel-plugin-macros properly: `+"https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/user.md")}return e(r)}}function nodeResolvePath(e,r){return n.sync(e,{basedir:r,extensions:[".js",".ts",".tsx",".mjs",".cjs",".jsx"],paths:[t.resolve(__dirname,"../../")]})}function macrosPlugin(e,{require:r=require,resolvePath:o=nodeResolvePath,isMacrosName:t=testMacrosRegex,...n}={}){function interopRequire(e){const o=r(e);return o&&o.__esModule&&o.default?o.default:o}return{name:"macros",visitor:{Program(r,a){r.traverse({ImportDeclaration(r){const i=looksLike(r,{node:{source:{value:e=>t(e)}}});if(!i){return}const s=r.node.specifiers.map((e=>({localName:e.local.name,importedName:e.type==="ImportDefaultSpecifier"?"default":e.imported.name})));const c=r.node.source.value;const p=applyMacros({path:r,imports:s,source:c,state:a,babel:e,interopRequire:interopRequire,resolvePath:o,options:n});if(!p||!p.keepImports){r.remove()}},VariableDeclaration(r){const isMacros=e=>looksLike(e,{node:{init:{callee:{type:"Identifier",name:"require"},arguments:e=>e.length===1&&t(e[0].value)}}});r.get("declarations").filter(isMacros).forEach((r=>{const t=r.node.id.name?[{localName:r.node.id.name,importedName:"default"}]:r.node.id.properties.map((e=>({localName:e.value.name,importedName:e.key.name})));const i=r.get("init");const s=i.node.arguments[0].value;const c=applyMacros({path:i,imports:t,source:s,state:a,babel:e,interopRequire:interopRequire,resolvePath:o,options:n});if(!c||!c.keepImports){r.remove()}}))}})}}}}function applyMacros({path:e,imports:r,source:o,state:n,babel:a,interopRequire:i,resolvePath:s,options:c}){const{file:{opts:{filename:p=""}}}=n;let l=false;const u=r.reduce(((r,{importedName:o,localName:t})=>{const n=e.scope.getBinding(t);r[o]=n.referencePaths;l=l||Boolean(r[o].length);return r}),{});const m=o.indexOf(".")===0;const f=s(o,t.dirname(getFullFilename(p)));const d=i(f);if(!d.isBabelMacro){throw new Error(`The macro imported from "${o}" must be wrapped in "createMacro" `+`which you can get from "babel-plugin-macros". `+`Please refer to the documentation to see how to do this properly: https://github.com/kentcdodds/babel-plugin-macros/blob/master/other/docs/author.md#writing-a-macro`)}const g=getConfig(d,p,o,c);let b;try{n.file.scope.path.traverse({Identifier(){}});b=d({references:u,source:o,state:n,babel:a,config:g,isBabelMacrosCall:true})}catch(e){if(e.name==="MacroError"){throw e}e.message=`${o}: ${e.message}`;if(!m){e.message=`${e.message} Learn more: https://www.npmjs.com/package/${o.replace(/^((?:@[^/]+\/)?[^/]+).*/,"$1")}`}throw e}return b}function getConfigFromFile(e,r){try{const o=getConfigExplorer().search(r);if(o){return{options:o.config[e],path:o.filepath}}}catch(e){return{error:e}}return{}}function getConfigFromOptions(e,r){if(r.hasOwnProperty(e)){if(r[e]&&typeof r[e]!=="object"){console.error(`The macro plugin options' ${e} property was not an object or null.`)}else{return{options:r[e]}}}return{}}function getConfig(e,r,o,t){const{configName:n}=e.options;if(n){const e=getConfigFromFile(n,r);const a=getConfigFromOptions(n,t);if(a.options===undefined&&e.options===undefined&&e.error!==undefined){console.error(`There was an error trying to load the config "${n}" `+`for the macro imported from "${o}. `+`Please see the error thrown for more information.`);throw e.error}if(e.options!==undefined&&a.options!==undefined&&typeof e.options!=="object"){throw new Error(`${e.path} specified a ${n} config of type `+`${typeof a.options}, but the the macros plugin's `+`options.${n} did contain an object. Both configs must `+`contain objects for their options to be mergeable.`)}return{...a.options,...e.options}}return undefined}function getFullFilename(e){if(t.isAbsolute(e)){return e}return t.join(process.cwd(),e)}function looksLike(e,r){return e&&r&&Object.keys(r).every((o=>{const t=r[o];const n=e[o];if(typeof t==="function"){return t(n)}return isPrimitive(t)?t===n:looksLike(n,t)}))}function isPrimitive(e){return e==null||/^[sbn]/.test(typeof e)}e.exports=macrosPlugin;Object.assign(e.exports,{createMacro:createMacro,MacroError:MacroError})},603:e=>{e.exports=require("cosmiconfig")},17:e=>{e.exports=require("path")},606:e=>{e.exports=require("resolve")}};var r={};function __nccwpck_require__(o){var t=r[o];if(t!==undefined){return t.exports}var n=r[o]={exports:{}};var a=true;try{e[o](n,n.exports,__nccwpck_require__);a=false}finally{if(a)delete r[o]}return n.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var o=__nccwpck_require__(146);module.exports=o})();